

Here is a comprehensive breakdown of your project. You can save this as a reference guide. It covers the final corrected code and explains every logic concept we discussed, from State Snapshots to Controlled Components.

React Currency Converter: Code Documentation
Part 1: The Child Component (InputBox.jsx)
Role: The "Body." It displays data and captures user input, but it does not make decisions. It relies entirely on props from the parent.

The Code
JavaScript

import React, { useId } from 'react'

function InputBox({
    label,
    amount,
    onAmountChange,
    onCurrencyChange,
    currencyOptions = [],
    selectCurrency = "usd",
    amountDisabled = false,
    currencyDisabled = false,
    className = "",
}) {
    const id = useId();

    return (
        <div className={`bg-white p-3 rounded-lg text-sm flex ${className}`}>
            {/* --- Left Side: Number Input --- */}
            <div className='w-1/2'>
                <label htmlFor={id} className='text-black/40 mb-2 inline-block'>
                    {label}
                </label>
                <input
                    id={id}
                    type="number"
                    className='outline-none w-full bg-transparent py-1.5'
                    placeholder='Amount'
                    disabled={amountDisabled}
                    value={amount} 
                    // CRITICAL: Handles the "Sticky 0" and "String vs Number" issues
                    onChange={(e) => onAmountChange && onAmountChange(Number(e.target.value))}
                />
            </div>

            {/* --- Right Side: Currency Dropdown --- */}
            <div className='w-1/2 flex flex-wrap justify-end text-right'>
                <p className='text-black/40 mb-2 w-full'>Currency Type</p>
                <select
                    className='rounded-lg px-1 py-1 bg-gray-100 cursor-pointer outline-none'
                    value={selectCurrency} // Forces dropdown to match state
                    onChange={(e) => { onCurrencyChange && onCurrencyChange(e.target.value) }}
                    disabled={currencyDisabled}
                >
                    {/* DYNAMIC LOOP */}
                    {currencyOptions.map((currency) => (
                        <option key={currency} value={currency}>
                            {currency} 
                        </option>
                    ))}
                </select>
            </div>
        </div>
    )
}

export default InputBox
Key Concepts Explained
1. useId() Hook

Purpose: Accessibility.

How it works: Generates a unique ID (like :r1:). We link the <label> to the <input> using this ID. This ensures that clicking the word "From" automatically activates the input box next to it.

2. Handling Numbers (onChange)

The Issue: HTML inputs always return text strings (e.g., "100").

The Fix: Number(e.target.value) converts the string back to a math-ready number.

The "037" Bug: Without Number(), typing 7 next to 0 results in "07" (string). With Number(), 07 becomes 7.

3. The Dropdown Logic (.map)

Purpose: To create the list of currencies automatically without writing 100 <option> tags manually.

The Bug We Fixed: We originally had <option></option>. We added {currency} inside the tag so the user can actually see the text (e.g., "USD").

The Key: key={currency} is required by React to track items efficiently if the list order changes.

4. Controlled Dropdown (value={selectCurrency})

Purpose: To make the "Swap" feature work visually.

Logic: It locks the dropdown display to the variable passed from the parent. If App.jsx changes the variable from "usd" to "inr", this line forces the dropdown to switch to "inr".

Part 2: The Parent Component (App.jsx)
Role: The "Brain." It holds the State (memory), fetches the API data, and performs the mathematical conversion.

The Code
JavaScript

import { useState } from 'react'
import useCurrencyInfo from './hooks/UseCurrencyInfo'
import { InputBox } from './components/index.js'

function App() {
  const [amount, setAmount] = useState(0);
  const [from, setFrom] = useState('usd');
  const [to, setTo] = useState('inr');
  const [ConvertedAmount, setConvertedAmount] = useState(0);
  
  // Custom Hook to fetch data
  const currencyInfo = useCurrencyInfo(from);
  
  // Extract keys for dropdown (['usd', 'inr', 'eur'...])
  const Options = Object.keys(currencyInfo || {}); 

  const convert = () => {
    if(currencyInfo[to]){
        setConvertedAmount(amount * currencyInfo[to]);
    }
  }

  // The Swap Logic
  const swap = () => {
    setFrom(to);
    setTo(from);
    setAmount(ConvertedAmount);
    setConvertedAmount(amount);
  }

  return (
    <div className='w-full h-screen... (styling removed for brevity)'>
      <div className='w-full'>
         {/* ... Card Container ... */}
          <form onSubmit={(e) => {
            e.preventDefault();
            convert();
          }}>
            
            {/* FROM Input */}
            <InputBox
                label="from"
                amount={amount}
                currencyOptions={Options}
                onCurrencyChange={(currency) => setFrom(currency)}
                selectCurrency={from} // Must match InputBox prop name!
                onAmountChange={(amount) => setAmount(amount)}
            />

            {/* SWAP Button */}
            <button onClick={swap}>swap</button>

            {/* TO Input */}
            <InputBox
                label="to"
                amount={ConvertedAmount}
                currencyOptions={Options}
                onCurrencyChange={(currency) => setTo(currency)}
                selectCurrency={to} 
                amountDisabled 
            />

            <button type='submit'>Convert {from} to {to}</button>

          </form>
      </div>
    </div>
  )
}
export default App
Key Concepts Explained
1. State Management

We use useState to keep track of four things:

amount (User input)

from (Source currency)

to (Target currency)

ConvertedAmount (Math result)

Rule: When any of these change, React re-paints the screen.

2. The Swap Logic (State Snapshots)

The Code:

JavaScript

setFrom(to);
setTo(from);
The Concept: In standard programming, a=b; b=a fails (collision). In React, this works because from and to are snapshots of the values at the start of the function. React queues the updates for after the function finishes, allowing a perfect swap without a temporary variable.

3. Connection with InputBox (Props)

The Prop Mismatch Bug: We discovered that if App passes selectCurrency but InputBox expects selectedCurrency, the connection breaks. We fixed this by ensuring the names match exactly.

Data Flow:

App holds the variable from.

App passes it down: selectCurrency={from}.

InputBox receives it and locks the dropdown.

User changes dropdown -> InputBox calls setFrom -> App updates state -> Cycle repeats.

4. Short-Circuit Logic

In App.jsx, we used currencyInfo || {}. This prevents the app from crashing if the API call fails or is slow to load (undefined). It provides an empty object as a fallback.